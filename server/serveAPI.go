package server

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	handler "github.com/nordluma/go-bookstore/handler"
	"github.com/nordluma/go-bookstore/util"
)

type handlerAPI struct {
	requestPool *sync.Pool // holds: *handler.Request
	bufferPool  *sync.Pool // holds: *bytes.Buffer
}

func newHandlerAPI() *handlerAPI {
	return &handlerAPI{
		requestPool: &sync.Pool{
			New: func() interface{} {
				return new(handler.Request)
			},
		},
		bufferPool: &sync.Pool{
			New: func() interface{} {
				return new(bytes.Buffer)
			},
		},
	}
}

func (handlerAPI *handlerAPI) ServeHTTP(
	w http.ResponseWriter,
	r *http.Request,
) {
	// start timer to measure request durations
	startTime := time.Now()

	// prepare request context
	ctx := context.Background()

	authorization := r.Header.Get("Authorization")
	requestBody, logRequestBody := handlerAPI.getRequestBody(r.Body)

	request := handlerAPI.requestPool.Get().(*handler.Request)
	request.Authorization = authorization
	request.Body = requestBody
	request.URL = r.URL
	request.Method = r.Method

	// response for the request generated by core layer function
	var response interface{}
	// error that occurred during processing of the request
	var err error
	var httpResponseStatus int
	var logResponseBody string

	defer func() {
		// return pooled values back to the appropriate `sync.Pool`
		handlerAPI.requestPool.Put(request)

		// Log the request
		duration := time.Now().Sub(startTime)
		log.Printf(
			"%v: status=%v method=%v uri=%v durations=%v",
			startTime,
			httpResponseStatus,
			r.Method,
			r.RequestURI,
			duration,
		)
		log.Printf("request=%v", logRequestBody)

		if response != nil {
			log.Printf("response=%v", logResponseBody)
		}
	}()

	response, err = handler.Handle(ctx, request)
	if err == nil {
		httpResponseStatus = http.StatusOK
	} else {
		isError, errorCode, cause, errorType := util.IsError(err)
		if isError == true {
			response = util.ErrorResponse{
				ErrorCode: errorCode,
				Cause:     cause,
			}

			httpResponseStatus = util.MapErrorTypeToHTTPStatus(errorType)
		} else {
			response = nil
			httpResponseStatus = util.MapErrorTypeToHTTPStatus(err)
		}
	}

	responseBuffer := handlerAPI.bufferPool.Get().(*bytes.Buffer)
	responseBuffer.Reset()

	if response != nil {
		shouldGzip := err == nil
		logResponseBody = handlerAPI.makeResponsebody(
			shouldGzip,
			responseBuffer,
			response,
		)

		if shouldGzip == true {
			w.Header().Set("Content-Type", "application/json; charset=utf-8")

			w.Header().
				Set("Content-Length", strconv.Itoa(responseBuffer.Len()))
		}
	}

	w.WriteHeader(httpResponseStatus)
	w.Write(responseBuffer.Bytes())

	handlerAPI.bufferPool.Put(responseBuffer)
}

func (handlerAPI *handlerAPI) getRequestBody(
	reader io.Reader,
) (io.Reader, string) {
	buffer := handlerAPI.bufferPool.Get().(*bytes.Buffer)
	buffer.Reset()

	io.Copy(buffer, reader)
	body := buffer.String()

	handlerAPI.bufferPool.Put(buffer)

	return strings.NewReader(body), body
}

func (handlerAPI *handlerAPI) makeResponsebody(
	shouldGzip bool,
	writer io.Writer,
	response interface{},
) string {
	if response == nil {
		return ""
	}

	respRawBody := handlerAPI.bufferPool.Get().(*bytes.Buffer)
	respRawBody.Reset()

	if shouldGzip {
		gzipper := gzip.NewWriter(writer)
		writeResponse(io.MultiWriter(respRawBody, gzipper), response)
		gzipper.Close()
	} else {
		writeResponse(io.MultiWriter(respRawBody, writer), response)
	}

	rawBody := trimEOL(respRawBody.String())
	handlerAPI.bufferPool.Put(respRawBody)

	return rawBody
}

func writeResponse(writer io.Writer, response interface{}) {
	switch resp := response.(type) {
	case []byte:
		writer.Write(resp)
	default:
		json.NewEncoder(writer).Encode(response)
	}
}

func trimEOL(json string) string {
	n := len(json)
	if n > 0 && json[n-1] == '\n' {
		return json[:n-1]
	}

	return json
}
